# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:27:35+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic
from fastapi import Query
from starlette.requests import Request

from models import (
    AccessTokenToPut,
    ActionToPost,
    AdditionalDeviceInformation,
    ApiActionsIdGetResponse,
    ApiCustomDeviceGetResponse,
    ApiDevicesByEnergyGetResponse,
    ApiDevicesBySubTypeGetResponse,
    ApiDevicesGetResponse,
    ApiPicoGetResponse,
    ApiPicoHistoryIdGetResponse,
    ApiPicoLoadmanagementgroupGetResponse,
    ApiRegisterForRealtimeApiGetResponse,
    ApiValuesInPastMultipleIdGetResponse,
    ApiVirtualBillingMeterActiveGetResponse,
    ApiVirtualBillingMetersGetResponse,
    ApiVirtualTariffConsumptionGetResponse,
    ApiVirtualTariffGetResponse,
    ApiVirtualTariffsForPropertyIdGetResponse,
    CustomDeviceToPost,
    Device,
    DeviceInPast,
    DeviceToPost,
    FolderData,
    FolderMenuConfiguration,
    FolderMenuItem,
    FolderSettings,
    MBusData,
    MeterEnergyType,
    MeterFolderInformation,
    MeterFolderInformationToPost,
    MeterSubType,
    Object,
    PicoChargingData,
    PicoLoadmanagementGroupDto,
    PicoSettingsDto,
    RegisterRealtimeApiData,
    SmartMeDeviceConfigurationContainer,
    SubUserData,
    User,
    ValuesData,
    VirtualTariffsOfFolder,
    VMeterToActivate,
    VMeterToDeactivate,
)

app = MCPProxy(
    description='With the smart-me REST API you get Access to all your devices in the smart-me Cloud and you can add your own devices. So its an easy way to add the smart-me Cloud support to your Hardware or Software Product.',
    title='smart-me',
    version='v1',
    servers=[{'url': 'https://smart-me.com:443'}],
)


@app.put(
    '/api/AccessToken',
    description=""" Creates a Access Token to write on a Card (e.g. NFC) """,
    tags=['token_management', 'user_authentication'],
)
def access_token__put(body: AccessTokenToPut):
    """
    Creates a Access Token to write on a Card (e.g. NFC)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/Account/login',
    tags=[
        'token_management',
        'user_authentication',
        'device_management',
        'action_management',
        'folder_management',
        'meter_management',
        'api_registration_management',
        'health_monitoring',
        'mbus_data_management',
        'smart_me_device_configuration',
        'subuser_account_management',
        'user_account_management',
        'device_data_retrieval',
        'virtual_meter_management',
        'virtual_tariff_management',
        'user_folder_management',
        'oauth_authorization',
        'pico_charging_management',
        'load_management_operations',
        'pico_settings_management',
        'cable_lock_management',
    ],
)
def account__login():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/Account/login',
    tags=[
        'token_management',
        'user_authentication',
        'device_management',
        'action_management',
        'folder_management',
        'meter_management',
        'api_registration_management',
        'health_monitoring',
        'mbus_data_management',
        'smart_me_device_configuration',
        'subuser_account_management',
        'user_account_management',
        'device_data_retrieval',
        'virtual_meter_management',
        'virtual_tariff_management',
        'user_folder_management',
        'oauth_authorization',
        'pico_charging_management',
        'load_management_operations',
        'pico_settings_management',
        'cable_lock_management',
    ],
)
def post_api__account_login():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/Actions',
    description=""" Set an action for the specified device. """,
    tags=['device_management', 'action_management'],
)
def actions__post(body: ActionToPost):
    """
    Set an action for the specified device.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/Actions/{id}',
    description=""" Gets all available Actions of a Device """,
    tags=['device_management', 'action_management'],
)
def actions__get(id: str):
    """
    Gets all available Actions of a Device
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/AdditionalDeviceInformation/{id}',
    description=""" Gets the additional information (e.g. Firmware Version) about a device. """,
    tags=['device_management', 'device_data_retrieval'],
)
def additional_device_information__get(id: str):
    """
    Gets the additional information (e.g. Firmware Version) about a device.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/CustomDevice',
    description=""" Gets all Devices """,
    tags=['device_management'],
)
def custom_device__get():
    """
    Gets all Custom Devices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/CustomDevice',
    description=""" Creates or updates a Custom Device or updates it's values.
            A Custom Device can be any device that like to add some measurement values to the smart-me Cloud.
            Only use a custom device for all non meters.
            For a new device leave the ID empty. To create a device you have to set the DeviceEnergyType.
            To update values, add the ID of the device and the values you like to set.  (See the Data Type Model for more Information) """,
    tags=['device_management'],
)
def custom_device__post(body: CustomDeviceToPost):
    """
    Creates or updates a Custom Device or updates it's values.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/CustomDevice/{id}',
    description=""" Gets a Device by it's ID """,
    tags=['device_management'],
)
def get_api__custom_device__id(id: str):
    """
    Gets a Custom Device by it's ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/DeviceBySerial',
    description=""" Gets a Device by it's Serial Number. The Serial is the part before the "-". """,
    tags=['device_management', 'device_data_retrieval'],
)
def device_by_serial__get(serial: int):
    """
    Gets a Device by it's Serial Number. The Serial is the part before the "-".
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/Devices',
    description=""" Gets all Devices """,
    tags=['device_management', 'device_data_retrieval'],
)
def devices__get():
    """
    Gets all Devices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/Devices',
    description=""" Creates or updates a Device or updates it's values. 
            For a new device leave the ID empty. To create a device you have to set the DeviceEnergyType.
            To update values, add the ID of the device and the values you like to set.  (See the Data Type Model for more Information) """,
    tags=['device_management'],
)
def devices__post(body: DeviceToPost):
    """
    Creates or updates a Device or updates it's values.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/Devices/{id}',
    description=""" Gets a Device by it's ID """,
    tags=['device_management', 'device_data_retrieval'],
)
def get_api__devices__id(id: str):
    """
    Gets a Device by it's ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/Devices/{id}',
    description=""" Updates the On/Off Switch on a device
            For new implementations please use the "actions" command """,
    tags=['device_management', 'action_management'],
)
def devices__put(
    id: str,
    switch_state: bool = Query(..., alias='switchState'),
    switch_number: Optional[int] = Query(None, alias='switchNumber'),
):
    """
    Updates the On/Off Switch on a device.
            For new implementations please use the "actions" command
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/DevicesByEnergy',
    description=""" Gets all Devices for an Energy Type """,
    tags=['device_management', 'meter_management', 'device_data_retrieval'],
)
def devices_by_energy__get(
    meter_energy_type: MeterEnergyType = Query(..., alias='meterEnergyType')
):
    """
    Gets all Devices for an Energy Type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/DevicesBySubType',
    description=""" Gets all Devices by it's Sub Type (e.g. E-Charging Station) """,
    tags=['device_management', 'meter_management', 'device_data_retrieval'],
)
def devices_by_sub_type__get(
    meter_sub_type: MeterSubType = Query(..., alias='meterSubType')
):
    """
    Gets all Devices by it's Sub Type (e.g. E-Charging Station)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/FastSendDeviceValues/{id}',
    tags=['device_management', 'action_management', 'device_data_retrieval'],
)
def fast_send_device_values__get(id: str):
    """
    Force a device to send the data every second (if supported). This for about 30s.
            Don't use this call to force a device to send the data every second for a longer time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/Folder/{id}',
    description=""" Gets the Values for a folder or a meter """,
    tags=['folder_management', 'meter_management'],
)
def folder__get(id: str):
    """
    Gets the Values for a folder or a meter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/FolderMenu', tags=['folder_management', 'user_folder_management'])
def folder_menu__get(filter: Optional[str] = None):
    """
    Gets the folder menu items (each item might contain child items)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/api/FolderMenu', tags=['folder_management', 'user_folder_management'])
def folder_menu__post(body: FolderMenuConfiguration):
    """
    Creates and updates the folder menu items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/Health', tags=['health_monitoring'])
def health__get():
    """
    A method returning HTTP 200 OK when queried.
            It is used by Kubernetes probes to determine whether the app is healthy.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/MBus',
    description=""" M-BUS API: Adds data of a M-BUS Meter to the smart-me Cloud.
            Just send us the M-BUS Telegram (RSP_UD) and we will do the Rest. """,
    tags=['meter_management', 'mbus_data_management'],
)
def m_bus__post(body: MBusData):
    """
    M-BUS API: Adds data of a M-BUS Meter to the smart-me Cloud.
            Just send us the M-BUS Telegram (RSP_UD) and we will do the Rest.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/MeterFolderInformation',
    description=""" Sets the Name of a Meter or a Folder """,
    tags=['meter_management', 'folder_management'],
)
def meter_folder_information__post(body: MeterFolderInformationToPost):
    """
    Sets the Name of a Meter or a Folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/MeterFolderInformation/{id}',
    description=""" Beta: Gets the General Information for a Meter or a Folder """,
    tags=['folder_management', 'meter_management'],
)
def meter_folder_information__get(id: str):
    """
    Beta: Gets the General Information for a Meter or a Folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/MeterValues/{id}',
    description=""" Gets the Values for a Meter at a given Date. The first Value found before the given Date is returned. """,
    tags=['meter_management', 'device_data_retrieval'],
)
def meter_values__get(id: str, date: datetime = ...):
    """
    Gets the Values for a Meter at a given Date.
            The first Value found before the given Date is returned.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/RegisterForRealtimeApi',
    description=""" Gets all registrations for the Realtime API. """,
    tags=['api_registration_management'],
)
def register_for_realtime_api__get():
    """
    Gets all registrations for the Realtime API.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/RegisterForRealtimeApi',
    description=""" Creates a new registration for the realtime API. The Realtime API sends you the data of the registred devices as soon as we have them on the cloud. More Information about the realtime API: https://www.smart-me.com/Description/api/realtimeapi.aspx """,
    tags=['api_registration_management', 'device_management'],
)
def register_for_realtime_api__post(body: RegisterRealtimeApiData):
    """
    Creates a new registration for the realtime API. The Realtime API sends you the data of the registred devices as soon as we have them on the cloud.
             More Information about the realtime API: https://www.smart-me.com/Description/api/realtimeapi.aspx
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/RegisterForRealtimeApi/{id}',
    description=""" Deletes a realtime API registration. """,
    tags=['api_registration_management'],
)
def register_for_realtime_api__delete(id: str):
    """
    Deletes a realtime API registration.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/SmartMeDeviceConfiguration',
    tags=['smart_me_device_configuration', 'device_management'],
)
def smart_me_device_configuration__post(body: SmartMeDeviceConfigurationContainer):
    """
    Sets the configuration of a smart-me device. The device needs to be online.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/SmartMeDeviceConfiguration/{id}',
    tags=['smart_me_device_configuration', 'device_management'],
)
def smart_me_device_configuration__get(id: str):
    """
    Gets the configuration of a smart-me device.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/api/SubUser', tags=['subuser_account_management'])
def sub_user__post(body: SubUserData):
    """
    Creates or updates a subuser.
            To create a new user set no ID (empty)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/SubUser/{id}', tags=['subuser_account_management', 'user_account_management']
)
def sub_user__delete(id: str):
    """
    Delete a subuser
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/SubUser/{id}', tags=['subuser_account_management', 'user_account_management']
)
def sub_user__get(id: str):
    """
    Get a sub user. The user must be assigend to the user that makes this call.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/api/User', tags=['user_account_management', 'subuser_account_management'])
def user__delete():
    """
    Triggers user account deletion.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/User',
    description=""" Gets the informations for the user. """,
    tags=['user_account_management', 'user_authentication'],
)
def user__get():
    """
    Gets the informations for the user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/Values/{id}', tags=['device_management', 'device_data_retrieval'])
def values__get(id: str):
    """
    Gets all (last) values of a device
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/ValuesInPast/{id}',
    description=""" Gets the Values for a device at a given Date. The first Value found before the given Date is returned. """,
    tags=['device_data_retrieval', 'device_management'],
)
def values_in_past__get(id: str, date: datetime = ...):
    """
    Gets all (last) values of a device
            The first Value found before the given Date is returned.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/ValuesInPastMultiple/{id}', tags=['device_data_retrieval', 'meter_management']
)
def values_in_past_multiple__get(
    id: str,
    start_date: datetime = Query(..., alias='startDate'),
    end_date: datetime = Query(..., alias='endDate'),
    interval: int = ...,
):
    """
    Gets multiple values of a device. This call needs a smart-me professional licence.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualBillingMeterActive',
    description=""" Beta: Gets all active virtual meters. """,
    tags=['meter_management', 'virtual_meter_management'],
)
def virtual_billing_meter_active__get():
    """
    Beta: Gets all active virtual meters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/VirtualBillingMeterActive',
    description=""" Beta: Virtual Meter API: Activates a Meter and add the Consumption to a Virtual Meter assosiated with the User. """,
    tags=['virtual_meter_management', 'meter_management'],
)
def virtual_billing_meter_active__post(body: VMeterToActivate):
    """
    Beta: Virtual Meter API: Activates a Meter and add the Consumption to a Virtual Meter assosiated with the User.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/VirtualBillingMeterDeactivate',
    description=""" Beta: Virtual Meter API: Deactivates a Virtual Meter. """,
    tags=['virtual_meter_management', 'device_management'],
)
def virtual_billing_meter_deactivate__post(body: VMeterToDeactivate):
    """
    Beta: Virtual Meter API: Deactivates a Virtual Meter.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualBillingMeters',
    description=""" Beta: Gets all Meters available to activate as a Virtual Meter. """,
    tags=['meter_management', 'virtual_meter_management'],
)
def virtual_billing_meters__get():
    """
    Beta: Gets all Meters available to activate as a Virtual Meter.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualMeterCalculateFormula',
    description=""" Calculates a virtual meter from a formula.
            
            A meter is coded as ID("METERID")
            Ariphmetical operators:
             ()  parentheses;  
             +   plus (a + b); 
             -  minus (a - b); 
             *  multiplycation symbol (a * b); 
             /  divide symbol (a / b); 
            Example: (ID("63ac09cb-4e5f-4f3e-bd27-ad8c30bdfc0c") + ID("0209555e-9dc4-4e84-a166-a864488b4b12")) * 2 """,
    tags=['meter_management', 'virtual_meter_management'],
)
def virtual_meter_calculate_formula__get(formula: str):
    """
    Calculates a virtual meter from a formula.
            A meter is coded as ID("METERID")
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualTariff',
    description=""" Gets all Virtual Tariffs of a user """,
    tags=['virtual_tariff_management', 'user_account_management'],
)
def virtual_tariff__get():
    """
    Gets all Virtual Tariffs of a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualTariff/{id}',
    description=""" Gets all virtual tariffs of a folder """,
    tags=['virtual_tariff_management', 'folder_management'],
)
def get_api__virtual_tariff__id(id: str):
    """
    Gets all virtual tariffs of a folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualTariffConsumption',
    description=""" Gets the consumption of a folder with a virtuall tariffs. """,
    tags=['folder_management', 'virtual_tariff_management'],
)
def virtual_tariff_consumption__get(
    folder_id: str = Query(..., alias='folderId'),
    start_date: datetime = Query(..., alias='startDate'),
    end_date: datetime = Query(..., alias='endDate'),
):
    """
    Gets the consumption of a folder with a virtuall tariffs.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualTariffsForProperty/{id}',
    description=""" Gets all Virtual Tariffs for a property (folder) """,
    tags=['virtual_tariff_management', 'folder_management'],
)
def virtual_tariffs_for_property__get(id: str):
    """
    Gets all Virtual Tariffs for a property (folder)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/VirtualTariffsStatusForProperty/{id}', tags=['virtual_tariff_management']
)
def virtual_tariffs_status_for_property__get(id: str):
    """
    Gets the calculation status for a virtual tariff property
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/api/folder/assign', tags=['folder_management'])
def folder_assign__post(source: str, target: str = ...):
    """
    Assign a folder (source) or meter to another folder (target). Can be used to create a folder structure.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/folder/settings/{id}', tags=['folder_management', 'user_folder_management']
)
def folder_settings__delete(id: str):
    """
    Deletes a folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/folder/settings/{id}', tags=['folder_management', 'meter_management'])
def folder_settings__get(id: str):
    """
    Gets the settings of a folder or meter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/api/folder/settings/{id}', tags=['folder_management', 'meter_management'])
def folder_settings__post(id: str, body: FolderSettings = ...):
    """
    Add or edit a folder or a meter. To add a new folder use and empty ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/folder/user/assign', tags=['folder_management', 'user_folder_management']
)
def user_to_folder_assign__delete(source: str, target: str = ...):
    """
    Deletes a user to folder assignement
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/folder/user/assign', tags=['folder_management', 'user_folder_management']
)
def user_to_folder_assign__post(
    source: str, target: str = ..., old_folder: str = Query(..., alias='oldFolder')
):
    """
    Assign a user to a folder
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/oauth/authorize', tags=['oauth_authorization', 'user_authentication'])
def o_auth__authorize(
    client_id: str,
    redirect_uri: str = ...,
    state: str = ...,
    scope: Optional[str] = None,
    client_secret: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/api/oauth/authorize', tags=['oauth_authorization', 'user_authentication'])
def post_api_oauth_authorize(
    client_id: str,
    redirect_uri: str = ...,
    state: str = ...,
    scope: Optional[str] = None,
    client_secret: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/pico', tags=['pico_charging_management'])
def pico__get():
    """
    Gets all pico charging stations for this user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/pico/charging/{id}',
    tags=['pico_charging_management', 'device_data_retrieval'],
)
def pico_charging__get(id: str):
    """
    Gets the active charging data of a pico station
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/pico/history/{id}', tags=['pico_charging_management', 'device_data_retrieval']
)
def pico_charging_history__get(id: str):
    """
    Gets the last charging history for a pico station
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/pico/loadmanagementgroup', tags=['load_management_operations'])
def get_api_pico_loadmanagementgroup():
    """
    GET: api/pico/loadmanagementgroup

            Returns all available load management groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/pico/loadmanagementgroup/current/{serial}',
    tags=['load_management_operations'],
)
def pico_loadmanagement_set_dynamic_current__post(serial: int, current: int = ...):
    """
    Sets the dynamic current of a load management group or a single station.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/api/pico/loadmanagementgroup/{id}', tags=['load_management_operations'])
def pico_loadmanagement_group__get(id: str):
    """
    GET: api/pico/loadmanagementgroup

            Returns a pico load management group by it's id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/pico/settings/{id}',
    tags=['pico_settings_management', 'pico_charging_management'],
)
def pico_settings__get(id: str):
    """
    GET: api/pico/settings

            Returns the settings of a pico charging station.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/pico/tryenablecablelock/{id}',
    tags=['cable_lock_management', 'device_management', 'pico_settings_management'],
)
def pico_enable_fix_cable_lock__post(id: str):
    """
    Try to fix lock the cable of a pico. The pico must be online and a cable (without car) needs to be connected. Otherwise this will fail.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
